//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ClientBase {

  private readonly config: IConfig;

  protected constructor(config: IConfig) {
    this.config = config;
  }

  protected transformOptions(options: RequestInit) {
    options.headers = {
      ...options.headers,
      standAloneToken: this.config.getAuthorization(),
    };
    return Promise.resolve(options);

  }

  protected transformResult(
    url: string,
    response: Response,
    processor: (response: Response) => any
  ) {
    console.log('Service call: ' + url);
    return processor(response);
  }
}

export interface IClient {

    /**
     * Add Alert comment
     * @param body Add comment to one alert
     */
    addComment(body: AlertCommentSecOps): Promise<boolean>;

    /**
     * Add comment to multiple Alerts
     * @param body Comment to add to several alert ids
     */
    addComments(body: AlertCommentSecOpsBulk): Promise<string[]>;

    /**
     * Delete Alert comment
     * @param body List of ID comments to delete
     */
    deleteComment(body: number[]): Promise<boolean>;

    /**
     * Get all Alert comments
     * @param body Alert ID lists
     */
    getList(body: number[]): Promise<AlertComments[]>;

    /**
     * Update Alert comment
     * @param commentId Comment id
     * @param body Updated comment
     */
    updateComment(commentId: string, body: AlertCommentSecOps): Promise<boolean>;

    /**
     * Update bulk Alert comments
     * @param body Bulk comment update resource
     */
    updateComments(body: AlertCommentSecOpsBulkUpdate): Promise<string>;

    /**
     * Get Alert without context
     * @param id Alert ID
     * @param tags (optional) If the parameter exists and the value is TRUE all the alert tags will be included in the response.
     * @param annotations (optional) If the parameter exists and the value is TRUE all the alert annotations will be included in the response.
     */
    get(id: string, tags: boolean | undefined, annotations: boolean | undefined): Promise<Alert>;

    /**
     * Get Alerts
     * @param limit The limit, max number of elements returned
     * @param offset The offset, start element in the element number
     * @param from The date from in epoch time,with milliseconds obtain from new Date(Long.parseLong(from))
     * @param to The date to in epoch time,with milliseconds,obtain from new Date(Long.parseLong(from))
     * @param orderby (optional) Field to order, must be:
    id, 
    domain,
    priority,
    context,
    category,
    srcPort,
    srcIp,
    srcHost,
    dstIp,
    dstPort,
    dstHost,
    protocol,
    username,
    application,
    engine,
    extraData,
    status,
    ack_status_date,
    createDate,
    updateDate.
     * @param orderasc (optional) Order Ascending
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     */
    getListByCriterias(limit: string, offset: string, from: string, to: string, orderby: string | undefined, orderasc: boolean | undefined, showAll: boolean | undefined): Promise<AlertExtended[]>;

    /**
     * Get Alert Statistics
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     * @deprecated
     */
    getListByCriteriasOverview(showAll: boolean | undefined): Promise<string>;

    /**
     * Get Alert statistics
     * @param hours (optional) Hours back to obtain data
     * @param from (optional) From to obtain data
     * @param type (optional) Type of result, may be 'raw', 'funnel, 'list'
     * @param filterName (optional) filter by name context
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     */
    getStatistics(hours: number | undefined, from: number | undefined, type: string | undefined, filterName: string | undefined, showAll: boolean | undefined): Promise<FunnelStatistics[]>;

    /**
     * Get Alert statuses
     * @param from (optional) The date from in epoch time, with miliseconds. Default value 24 hours before petition
     */
    listStatus(from: string | undefined): Promise<string>;

    /**
     * Update Alert status
     * @param id Alert ID
     * @param status Alert status with this possible values:
    UNREAD = 0;       
    UPDATED = 1;      
    FALSE POSTIVE = 2;
    WATCHED = 100;    
    CLOSED = 300;     
    REMINDER = 500;   
    RECOVERY = 600;   
    ANTI FLOOD = 700;
     */
    updateStatus(id: string, status: number): Promise<Alert>;

    /**
     * Update Alert status
     * @param status Alert status with this possible values:
    UNREAD = 0;       
    UPDATED = 1;      
    FALSE POSTIVE = 2;
    WATCHED = 100;    
    CLOSED = 300;     
    REMINDER = 500;   
    RECOVERY = 600;   
    ANTI FLOOD = 700;
     * @param body (optional) 
     */
    updateStatusLists(status: number, body: Blob | undefined): Promise<any>;

    /**
     * Get Alert definitions
     * @param nameFilter (optional) Alert name to filter
     * @param idFilter (optional) Alert id to filter
     * @param body (optional) 
     */
    getAlerts(nameFilter: string | undefined, idFilter: string | undefined, body: Pageable | undefined): Promise<AlertDefinition[]>;

    /**
     * Updated Alert definitions
     * @param body (optional) 
     */
    putAlerts(body: AlertDefinition | undefined): Promise<AlertDefinition>;

    /**
     * Create Alert definition
     * @param body (optional) 
     */
    postAlerts(body: AlertDefinition | undefined): Promise<AlertDefinition>;

    /**
     * Delete Alert definitions
     * @param alertIds List of alert definitions IDs
     * @return Deletion was successful
     */
    deleteAlerts(alertIds: string[]): Promise<void>;

    /**
     * Updates a batch of Alert definitions
     * @param body (optional) 
     */
    putAlertsBatch(body: AlertDefinition[] | undefined): Promise<AlertDefinition[]>;

    /**
     * Create batch of Alert definitions
     * @param body (optional) 
     */
    postAlertsBatch(body: AlertDefinition[] | undefined): Promise<AlertDefinition[]>;

    /**
     * Update Alert definition statuses
     * @param alertIds List of alert definitions IDs
     * @param enable Enable/disable alert definitions
     */
    putAlertStatus(alertIds: string[], enable: boolean): Promise<AlertSubscriptionUpdate>;

    /**
     * Assign Tag to Alert
     * @param body Alert IDs and tags to be set to the alerts
     */
    setTags(body: AlertTagsRequest): Promise<any>;
}

export class Client extends ClientBase implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add Alert comment
     * @param body Add comment to one alert
     */
    addComment(body: AlertCommentSecOps): Promise<boolean> {
        let url_ = this.baseUrl + "/v1/comments/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddComment(_response);
        });
    }

    protected processAddComment(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alert comment error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Add comment to multiple Alerts
     * @param body Comment to add to several alert ids
     */
    addComments(body: AlertCommentSecOpsBulk): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/comments/bulk/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddComments(_response);
        });
    }

    protected processAddComments(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alert comments error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Delete Alert comment
     * @param body List of ID comments to delete
     */
    deleteComment(body: number[]): Promise<boolean> {
        let url_ = this.baseUrl + "/v1/comments/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteComment(_response);
        });
    }

    protected processDeleteComment(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Get all Alert comments
     * @param body Alert ID lists
     */
    getList(body: number[]): Promise<AlertComments[]> {
        let url_ = this.baseUrl + "/v1/comments/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<AlertComments[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertComments[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alert comment error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertComments[]>(null as any);
    }

    /**
     * Update Alert comment
     * @param commentId Comment id
     * @param body Updated comment
     */
    updateComment(commentId: string, body: AlertCommentSecOps): Promise<boolean> {
        let url_ = this.baseUrl + "/v1/comments/update?";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined and cannot be null.");
        else
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateComment(_response);
        });
    }

    protected processUpdateComment(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Update bulk Alert comments
     * @param body Bulk comment update resource
     */
    updateComments(body: AlertCommentSecOpsBulkUpdate): Promise<string> {
        let url_ = this.baseUrl + "/v1/comments/bulk/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateComments(_response);
        });
    }

    protected processUpdateComments(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get Alert without context
     * @param id Alert ID
     * @param tags (optional) If the parameter exists and the value is TRUE all the alert tags will be included in the response.
     * @param annotations (optional) If the parameter exists and the value is TRUE all the alert annotations will be included in the response.
     */
    get(id: string, tags: boolean | undefined, annotations: boolean | undefined): Promise<Alert> {
        let url_ = this.baseUrl + "/v1/alerts/get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (tags === null)
            throw new Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            url_ += "tags=" + encodeURIComponent("" + tags) + "&";
        if (annotations === null)
            throw new Error("The parameter 'annotations' cannot be null.");
        else if (annotations !== undefined)
            url_ += "annotations=" + encodeURIComponent("" + annotations) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Alert> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Alert;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("There are no matching alerts for this ID", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Alert>(null as any);
    }

    /**
     * Get Alerts
     * @param limit The limit, max number of elements returned
     * @param offset The offset, start element in the element number
     * @param from The date from in epoch time,with milliseconds obtain from new Date(Long.parseLong(from))
     * @param to The date to in epoch time,with milliseconds,obtain from new Date(Long.parseLong(from))
     * @param orderby (optional) Field to order, must be:
    id, 
    domain,
    priority,
    context,
    category,
    srcPort,
    srcIp,
    srcHost,
    dstIp,
    dstPort,
    dstHost,
    protocol,
    username,
    application,
    engine,
    extraData,
    status,
    ack_status_date,
    createDate,
    updateDate.
     * @param orderasc (optional) Order Ascending
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     */
    getListByCriterias(limit: string, offset: string, from: string, to: string, orderby: string | undefined, orderasc: boolean | undefined, showAll: boolean | undefined): Promise<AlertExtended[]> {
        let url_ = this.baseUrl + "/v1/alerts/list?";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === undefined || offset === null)
            throw new Error("The parameter 'offset' must be defined and cannot be null.");
        else
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "orderby=" + encodeURIComponent("" + orderby) + "&";
        if (orderasc === null)
            throw new Error("The parameter 'orderasc' cannot be null.");
        else if (orderasc !== undefined)
            url_ += "orderasc=" + encodeURIComponent("" + orderasc) + "&";
        if (showAll === null)
            throw new Error("The parameter 'showAll' cannot be null.");
        else if (showAll !== undefined)
            url_ += "showAll=" + encodeURIComponent("" + showAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetListByCriterias(_response);
        });
    }

    protected processGetListByCriterias(response: Response): Promise<AlertExtended[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertExtended[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("There are no matching alerts for this period", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertExtended[]>(null as any);
    }

    /**
     * Get Alert Statistics
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     * @deprecated
     */
    getListByCriteriasOverview(showAll: boolean | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/alerts/listOverview?";
        if (showAll === null)
            throw new Error("The parameter 'showAll' cannot be null.");
        else if (showAll !== undefined)
            url_ += "showAll=" + encodeURIComponent("" + showAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetListByCriteriasOverview(_response);
        });
    }

    protected processGetListByCriteriasOverview(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get Alert statistics
     * @param hours (optional) Hours back to obtain data
     * @param from (optional) From to obtain data
     * @param type (optional) Type of result, may be 'raw', 'funnel, 'list'
     * @param filterName (optional) filter by name context
     * @param showAll (optional) Obtain all (false positive and close status included) Default:False
     */
    getStatistics(hours: number | undefined, from: number | undefined, type: string | undefined, filterName: string | undefined, showAll: boolean | undefined): Promise<FunnelStatistics[]> {
        let url_ = this.baseUrl + "/v1/alerts/statistics?";
        if (hours === null)
            throw new Error("The parameter 'hours' cannot be null.");
        else if (hours !== undefined)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (filterName === null)
            throw new Error("The parameter 'filterName' cannot be null.");
        else if (filterName !== undefined)
            url_ += "filterName=" + encodeURIComponent("" + filterName) + "&";
        if (showAll === null)
            throw new Error("The parameter 'showAll' cannot be null.");
        else if (showAll !== undefined)
            url_ += "showAll=" + encodeURIComponent("" + showAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: Response): Promise<FunnelStatistics[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FunnelStatistics[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Error in parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FunnelStatistics[]>(null as any);
    }

    /**
     * Get Alert statuses
     * @param from (optional) The date from in epoch time, with miliseconds. Default value 24 hours before petition
     */
    listStatus(from: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/alerts/listStatus?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListStatus(_response);
        });
    }

    protected processListStatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("There are no matching alerts for this period", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Update Alert status
     * @param id Alert ID
     * @param status Alert status with this possible values:
    UNREAD = 0;       
    UPDATED = 1;      
    FALSE POSTIVE = 2;
    WATCHED = 100;    
    CLOSED = 300;     
    REMINDER = 500;   
    RECOVERY = 600;   
    ANTI FLOOD = 700;
     */
    updateStatus(id: string, status: number): Promise<Alert> {
        let url_ = this.baseUrl + "/v1/alerts/updateStatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: Response): Promise<Alert> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Alert;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("There are no matching alerts for this ID", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Alert>(null as any);
    }

    /**
     * Update Alert status
     * @param status Alert status with this possible values:
    UNREAD = 0;       
    UPDATED = 1;      
    FALSE POSTIVE = 2;
    WATCHED = 100;    
    CLOSED = 300;     
    REMINDER = 500;   
    RECOVERY = 600;   
    ANTI FLOOD = 700;
     * @param body (optional) 
     */
    updateStatusLists(status: number, body: Blob | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/alerts/updateStatusList?";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "text/plain",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateStatusLists(_response);
        });
    }

    protected processUpdateStatusLists(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("One of the alerts does not exist with this id. Return list of not updated alerts. Not returned ids was updated", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get Alert definitions
     * @param nameFilter (optional) Alert name to filter
     * @param idFilter (optional) Alert id to filter
     * @param body (optional) 
     */
    getAlerts(nameFilter: string | undefined, idFilter: string | undefined, body: Pageable | undefined): Promise<AlertDefinition[]> {
        let url_ = this.baseUrl + "/v1/alertDefinitions?";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "nameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (idFilter === null)
            throw new Error("The parameter 'idFilter' cannot be null.");
        else if (idFilter !== undefined)
            url_ += "idFilter=" + encodeURIComponent("" + idFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAlerts(_response);
        });
    }

    protected processGetAlerts(response: Response): Promise<AlertDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDefinition[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDefinition[]>(null as any);
    }

    /**
     * Updated Alert definitions
     * @param body (optional) 
     */
    putAlerts(body: AlertDefinition | undefined): Promise<AlertDefinition> {
        let url_ = this.baseUrl + "/v1/alertDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutAlerts(_response);
        });
    }

    protected processPutAlerts(response: Response): Promise<AlertDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDefinition;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Unexpected internal error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDefinition>(null as any);
    }

    /**
     * Create Alert definition
     * @param body (optional) 
     */
    postAlerts(body: AlertDefinition | undefined): Promise<AlertDefinition> {
        let url_ = this.baseUrl + "/v1/alertDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostAlerts(_response);
        });
    }

    protected processPostAlerts(response: Response): Promise<AlertDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDefinition;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Unexpected internal error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDefinition>(null as any);
    }

    /**
     * Delete Alert definitions
     * @param alertIds List of alert definitions IDs
     * @return Deletion was successful
     */
    deleteAlerts(alertIds: string[]): Promise<void> {
        let url_ = this.baseUrl + "/v1/alertDefinitions?";
        if (alertIds === undefined || alertIds === null)
            throw new Error("The parameter 'alertIds' must be defined and cannot be null.");
        else
            alertIds && alertIds.forEach(item => { url_ += "alertIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAlerts(_response);
        });
    }

    protected processDeleteAlerts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Unexpected internal error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates a batch of Alert definitions
     * @param body (optional) 
     */
    putAlertsBatch(body: AlertDefinition[] | undefined): Promise<AlertDefinition[]> {
        let url_ = this.baseUrl + "/v1/alertDefinitions/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutAlertsBatch(_response);
        });
    }

    protected processPutAlertsBatch(response: Response): Promise<AlertDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDefinition[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Unexpected internal error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDefinition[]>(null as any);
    }

    /**
     * Create batch of Alert definitions
     * @param body (optional) 
     */
    postAlertsBatch(body: AlertDefinition[] | undefined): Promise<AlertDefinition[]> {
        let url_ = this.baseUrl + "/v1/alertDefinitions/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostAlertsBatch(_response);
        });
    }

    protected processPostAlertsBatch(response: Response): Promise<AlertDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDefinition[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Unexpected internal error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDefinition[]>(null as any);
    }

    /**
     * Update Alert definition statuses
     * @param alertIds List of alert definitions IDs
     * @param enable Enable/disable alert definitions
     */
    putAlertStatus(alertIds: string[], enable: boolean): Promise<AlertSubscriptionUpdate> {
        let url_ = this.baseUrl + "/v1/alertDefinitions/status?";
        if (alertIds === undefined || alertIds === null)
            throw new Error("The parameter 'alertIds' must be defined and cannot be null.");
        else
            alertIds && alertIds.forEach(item => { url_ += "alertIds=" + encodeURIComponent("" + item) + "&"; });
        if (enable === undefined || enable === null)
            throw new Error("The parameter 'enable' must be defined and cannot be null.");
        else
            url_ += "enable=" + encodeURIComponent("" + enable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutAlertStatus(_response);
        });
    }

    protected processPutAlertStatus(response: Response): Promise<AlertSubscriptionUpdate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertSubscriptionUpdate;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Alerts definition error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertSubscriptionUpdate>(null as any);
    }

    /**
     * Assign Tag to Alert
     * @param body Alert IDs and tags to be set to the alerts
     */
    setTags(body: AlertTagsRequest): Promise<any> {
        let url_ = this.baseUrl + "/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetTags(_response);
        });
    }

    protected processSetTags(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export interface AlertCommentSecOps {
    elementId?: string;
    commentType?: AlertCommentSecOpsCommentType;
    commentMsg?: string;
    commentTitle?: string;
    validContent?: boolean;
}

export interface AlertCommentSecOpsBulk {
    elementIds?: string[];
    commentMsg?: string;
    commentTitle?: string;
    commentType?: AlertCommentSecOpsBulkCommentType;
}

export interface AlertComments {
    idAlert?: number;
    comments?: Comment[];
}

export interface Comment {
    id?: number;
    author?: UserDomain;
    msg?: string;
    ack?: string;
    creationDate?: Date;
    updateDate?: Date;
    elementType?: string;
    elementId?: string;
    domain?: Domain;
    title?: string;
    status?: string;
    task?: boolean;
}

export interface Domain {
    id?: string;
    name?: string;
    status?: number;
    type?: number;
    updateDate?: Date;
    creationDate?: Date;
    subscribed?: number;
    daysLeft?: number;
    showLanding?: boolean;
    reseller?: Reseller;
    groupId?: number;
    alertsLastReseted?: Date;
}

export interface Reseller {
    id?: number;
    name?: string;
    preferences?: string;
    contactInformation?: string;
    pricePlans?: string;
    updateDate?: Date;
    creationDate?: Date;
    permPolicy?: string;
    menuView?: string;
    limits?: string;
    groupId?: number;
    webPreferences?: string;
}

export interface User {
    id?: string;
    email?: string;
    username?: string;
    telephone?: string;
    pwd?: string;
    status?: number;
    validation_token?: string;
    defaultDomain?: string;
    updateDate?: Date;
    creationDate?: Date;
    otpSecret?: string;
    loginAttempts?: number;
    recoveryAttempts?: number;
}

export interface UserDomain {
    id?: number;
    user?: User;
    domain?: Domain;
    lastTimeLogged?: Date;
    status?: number;
    creationDate?: Date;
    updateDate?: Date;
    pwd?: string;
    validationToken?: string;
    roleCustom?: number;
    rolesCustom?: number[];
    externalId?: string;
    owner?: boolean;
    alertsLastVisited?: Date;
}

export interface AlertCommentSecOpsBulkUpdate {
    idMap?: { [key: string]: number[]; };
    commentMsg?: string;
    commentTitle?: string;
    commentType?: AlertCommentSecOpsBulkUpdateCommentType;
}

export interface Alert {
    id?: number;
    domain?: string;
    priority?: number;
    context?: string;
    category?: string;
    srcPort?: number;
    srcIp?: string;
    srcHost?: string;
    dstIp?: string;
    dstPort?: number;
    dstHost?: string;
    protocol?: string;
    username?: string;
    application?: string;
    engine?: string;
    extraData?: string;
    alertDate?: Date;
    status?: number;
    ack_status_date?: Date;
    createDate?: Date;
    updateDate?: Date;
    scaled?: boolean;
    digest?: string;
    uniquedigest?: string;
    contexto?: Context;
    postAlertAction?: string;
    contextLabel?: string;
    contextSubscription?: number;
    shouldSend?: boolean;
    alertOwner?: string;
    fullExtraData?: string;
    alertLabel?: string;
}

export interface Category {
    id?: number;
    name?: string;
    owner?: string;
    subCategories?: SubCategory[];
}

export interface Context {
    id?: number;
    pilotContextId?: string;
    name?: string;
    category?: Category;
    subCategory?: SubCategory;
    application_id?: number;
    defaultParams?: string;
    includefields?: string;
    excludefields?: string;
}

export interface SubCategory {
    id?: number;
    name?: string;
    hasContext?: boolean;
    alert_category_id?: number;
    contextList?: Context[];
}

export interface AlertCorrelationContext {
    id?: string;
    nameId?: string;
    ownerEmail?: string;
    querySourceCode?: string;
    priority?: number;
    correlationTrigger?: CorrelationTrigger;
}

export interface AlertDefinition {
    id?: string;
    creationDate?: Date;
    name?: string;
    message?: string;
    description?: string;
    categoryId?: string;
    subcategory?: string;
    subcategoryId?: string;
    isActive?: boolean;
    isFavorite?: boolean;
    isAlertChain?: boolean;
    alertCorrelationContext?: AlertCorrelationContext;
    actionPolicyId?: string[];
}

export interface AlertExtended {
    id?: number;
    domain?: string;
    priority?: number;
    context?: string;
    category?: string;
    srcPort?: number;
    srcIp?: string;
    srcHost?: string;
    dstIp?: string;
    dstPort?: number;
    dstHost?: string;
    protocol?: string;
    username?: string;
    application?: string;
    engine?: string;
    extraData?: string;
    alertDate?: Date;
    status?: number;
    ack_status_date?: Date;
    createDate?: Date;
    updateDate?: Date;
    scaled?: boolean;
    digest?: string;
    uniquedigest?: string;
    contexto?: Context;
    postAlertAction?: string;
    contextLabel?: string;
    contextSubscription?: number;
    shouldSend?: boolean;
    alertOwner?: string;
    fullExtraData?: string;
    alertType?: string;
    alertMitreTactics?: string;
    alertMitreTechniques?: string;
    alertPriority?: string;
    alertDefinition?: AlertDefinition;
    allExtraDataFields?: { [key: string]: string; };
    tags?: string[];
    entities?: Entity[];
    commentsList?: Comment[];
    alertLabel?: string;
}

export interface CorrelationTrigger {
    kind: string;
}

export interface CorrelationTriggerDeviation extends CorrelationTrigger {
    threshold?: number;
    absolute?: boolean;
    aggregationColumn?: string[];
}

export interface CorrelationTriggerEach extends CorrelationTrigger {
    externalPeriod?: number;
    externalOffset?: number;
    internalPeriod?: number;
    internalOffset?: number;
}

export interface CorrelationTriggerGradient extends CorrelationTrigger {
    threshold?: number;
    absolute?: boolean;
    aggregationColumn?: string[];
}

export interface CorrelationTriggerLow extends CorrelationTrigger {
    period?: number;
    threshold?: number;
}

export interface CorrelationTriggerRolling extends CorrelationTrigger {
    period?: number;
    backPeriod?: number;
}

export interface CorrelationTriggerSeveral extends CorrelationTrigger {
    period?: number;
    threshold?: number;
    keys?: string[];
}

export interface Entity {
    id?: string;
    hostname?: string;
    url?: string;
    ip?: string;
    mac?: string;
    name?: string;
    location?: EntityLocation;
    email?: string;
    windowsDomain?: string;
    account?: string;
    hash?: string;
    impact?: string;
    creationDate?: number;
    modificationDate?: number;
    json?: string;
    domain?: string;
    extraDataMaps?: { [key: string]: string; };
    entityType?: EntityType;
    entitySuperTypes?: EntitySuperTypes[];
    entityFamily?: EntityFamily;
    direction?: EntityDirection;
    internalEntity?: boolean;
}

export interface EntityLocation {
    locationCountry?: string;
    locationCity?: string;
    locationState?: string;
    locationLat?: number;
    locationLon?: number;
}

export interface FunnelStatistics {
    total?: FunnelStatisticsValues;
    types?: { [key: string]: FunnelStatisticsValues; };
}

export interface FunnelStatisticsValues {
    total?: number;
    enriched?: number;
}

export interface Pageable {
    pageSize?: number;
    pageNumber?: number;
    sort?: Sort;
    offset?: number;
}

export interface Sort {
}

export interface AlertSubscriptionUpdate {
    correlationId?: string;
    updated?: { [key: string]: boolean; };
}

export interface AlertTagsRequest {
    alertIds?: string[];
    tags?: string[];
}

export enum AlertCommentSecOpsCommentType {
    ALERT = "ALERT",
    REPLY = "REPLY",
}

export enum AlertCommentSecOpsBulkCommentType {
    ALERT = "ALERT",
    REPLY = "REPLY",
}

export enum AlertCommentSecOpsBulkUpdateCommentType {
    ALERT = "ALERT",
    REPLY = "REPLY",
}

export enum EntityType {
    SOURCEIP = "SOURCEIP",
    DSTIP = "DSTIP",
    SOURCEDOMAIN = "SOURCEDOMAIN",
    DSTDOMAIN = "DSTDOMAIN",
    SOURCEHOST = "SOURCEHOST",
    DSTHOST = "DSTHOST",
    SOURCESYSTEMLOCATIONCOUNTRY = "SOURCESYSTEMLOCATIONCOUNTRY",
    SOURCESYSTEMLOCATIONCITY = "SOURCESYSTEMLOCATIONCITY",
    SOURCESYSTEMLOCATIONSTATE = "SOURCESYSTEMLOCATIONSTATE",
    SOURCESYSTEMLOCATIONLAT = "SOURCESYSTEMLOCATIONLAT",
    SOURCESYSTEMLOCATIONLON = "SOURCESYSTEMLOCATIONLON",
    DSTLOCATION = "DSTLOCATION",
    SOURCEUSER = "SOURCEUSER",
    DSTUSER = "DSTUSER",
    SOURCEUSERDOMAIN = "SOURCEUSERDOMAIN",
    DSTUSERDOMAIN = "DSTUSERDOMAIN",
    SOURCEUSERNAME = "SOURCEUSERNAME",
    DSTUSERNAME = "DSTUSERNAME",
    SOURCEURL = "SOURCEURL",
    DSTURL = "DSTURL",
    SOURCEMAC = "SOURCEMAC",
    DSTMAC = "DSTMAC",
    SOURCEEMAIL = "SOURCEEMAIL",
    DSTEMAIL = "DSTEMAIL",
    HASH = "HASH",
}

export enum EntitySuperTypes {
    DOMAIN = "DOMAIN",
    URL = "URL",
    IP = "IP",
    MAC = "MAC",
    USER = "USER",
    LOCATION = "LOCATION",
    EMAIL = "EMAIL",
    HASH = "HASH",
    HOSTNAME = "HOSTNAME",
    OTHER = "OTHER",
}

export enum EntityFamily {
    SYSTEM = "SYSTEM",
    USER = "USER",
    OTHER = "OTHER",
}

export enum EntityDirection {
    NONE = "NONE",
    SOURCE = "SOURCE",
    DESTINATION = "DESTINATION",
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

export interface IConfig {
  getAuthorization: () => string;
}